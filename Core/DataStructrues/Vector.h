// Copyright (c) 2025 Daniel Everland
// All rights reserved.

#pragma once
#include <cstdint>
#include <type_traits>
#include <float.h>
#include <format>
#include <iosfwd>
#include <ostream>
#include <valarray>

template<typename T, typename U>
concept valid_integral_and_floating_point_conversion = requires
{
    requires sizeof(T) >= sizeof(U);
    requires std::is_floating_point_v<T>;
};

template<class T>
struct TemplatedVector2D
{
    TemplatedVector2D() = default;
    TemplatedVector2D(T inX, T inY) : X(inX), Y(inY) { }
    
    template<class U>
    requires valid_integral_and_floating_point_conversion<T, U>
    TemplatedVector2D(const TemplatedVector2D<U>& other) : X(static_cast<T>(other.X)), Y(static_cast<T>(other.Y))
    {
        // In place instead of GTest as we cannot expect uncompilable code.
        static_assert(!(std::is_same<T, int>() && std::is_same<U, float>()));
        static_assert(!(std::is_same<T, float>() && std::is_same<U, double>()));
    }

    T X = 0;
    T Y = 0;

    TemplatedVector2D operator+(const TemplatedVector2D& rhs) const
    {
        return TemplatedVector2D(X + rhs.X, Y + rhs.Y);
    }

    TemplatedVector2D operator-(const TemplatedVector2D& rhs) const
    {
        return TemplatedVector2D(X - rhs.X, Y - rhs.Y);
    }

    bool operator==(const TemplatedVector2D& other) const
    {
        return X == other.X && Y == other.Y;
    }

    void Normalize()
    {
        T length = static_cast<T>(sqrt(X * X + Y * Y));
        
        if constexpr (std::is_integral_v<T>)
        {
            if (length == 0)
                return;
        }
        else if (length < FLT_EPSILON)
        {
            return;
        }
            
        X = static_cast<T>(X / length);
        Y = static_cast<T>(Y / length);
    }

    double Distance()
    {
        return std::sqrt(std::pow(X, 2) + std::pow(Y, 2));
    }

    template<typename U>
    TemplatedVector2D operator/ (U val) const
    {
        return TemplatedVector2D(X / val, Y / val);
    }

    std::string ToString() const
    {
        return std::format("({}, {})", X, Y);
    }
};

template<class T>
struct TemplatedVector
{
    TemplatedVector() = default;
    TemplatedVector(T inX, T inY, T inZ) : X(inX), Y(inY), Z(inZ) { }
    TemplatedVector(const TemplatedVector2D<T>& other) : X(other.X), Y(other.Y), Z(0) { }
    
    template<class U>
    requires valid_integral_and_floating_point_conversion<T, U>
    TemplatedVector(const TemplatedVector<U>& other) : X(static_cast<T>(other.X)), Y(static_cast<T>(other.Y)), Z(static_cast<T>(other.Z))
    {
        // In place instead of GTest as we cannot expect uncompilable code.
        static_assert(!(std::is_same<T, int>() && std::is_same<U, float>()));
        static_assert(!(std::is_same<T, float>() && std::is_same<U, double>()));
    }

    template<class U>
    explicit TemplatedVector(TemplatedVector<U> other) : X(static_cast<T>(other.X)), Y(static_cast<T>(other.Y)), Z(static_cast<T>(other.Z)) { }

    T X = 0;
    T Y = 0;
    T Z = 0;

    TemplatedVector operator+(const TemplatedVector& rhs) const
    {
        return TemplatedVector(X + rhs.X, Y + rhs.Y, Z + rhs.Z);
    }

    TemplatedVector operator-(const TemplatedVector& rhs) const
    {
        return TemplatedVector(X - rhs.X, Y - rhs.Y, Z - rhs.Z);
    }

    template<class U>
    TemplatedVector& operator=(const TemplatedVector2D<U>& other)
    {
        X = static_cast<T>(other.X);
        Y = static_cast<T>(other.Y);
        return *this;
    }

    bool operator==(const TemplatedVector& other) const
    {
        return X == other.X && Y == other.Y && Z == other.Z;
    }

    explicit operator TemplatedVector2D<T>() const
    {
        return { X, Y };
    }

    void Normalize()
    {
        T length = static_cast<T>(sqrt(X * X + Y * Y + Z * Z));
        
        if constexpr (std::is_integral_v<T>)
        {
            if (length == 0)
                return;
        }
        else if (length < FLT_EPSILON)
        {
            return;
        }
            
        X = static_cast<T>(X / length);
        Y = static_cast<T>(Y / length);
        Z = static_cast<T>(Z / length);
    }

    float SizeF() const
    {
        return std::sqrt(static_cast<float>(X * X + Y * Y + Z * Z));
    }
    
    template<typename U>
    TemplatedVector operator* (U val) const
    {
        return TemplatedVector(X * val, Y * val, Z * val);
    }

    std::string ToString() const
    {
        return std::format("({}, {}, {})", X, Y, Z);
    }
};

// Generated by Rider
template <class T>
struct std::hash<TemplatedVector<T>>
{
    std::size_t operator()(const TemplatedVector<T>& val) const
    {
        std::size_t seed = 0x60ABDCE1;
        seed ^= (seed << 6) + (seed >> 2) + 0x49A48D67 + val.X;
        seed ^= (seed << 6) + (seed >> 2) + 0x37BB98C7 + val.Y;
        seed ^= (seed << 6) + (seed >> 2) + 0x7D89EEC1 + val.Z;
        return seed;
    }
};

// Generated by Rider
template <class T>
struct std::hash<TemplatedVector2D<T>>
{
    std::size_t operator()(const TemplatedVector<T>& val) const
    {
        std::size_t seed = 0x0D6C6E9B;
        seed ^= (seed << 6) + (seed >> 2) + 0x36CED109 + val.X;
        seed ^= (seed << 6) + (seed >> 2) + 0x2FDEEBC5 + val.Y;
        return seed;
    }
};

// Output formatting
template<class T>
inline std::ostream& operator<<(std::ostream& os, const TemplatedVector<T>& v) {
    return os << "(" << v.X << ", " << v.Y << ", " << v.Z << ')';
}

template<class T>
inline std::ostream& operator<<(std::ostream& os, const TemplatedVector2D<T>& v) {
    return os << "(" << v.X << ", " << v.Y << ')';
}

// Common types
typedef TemplatedVector2D<int32_t> IntVector2D;
typedef TemplatedVector2D<float> Vector2D;

typedef TemplatedVector<int32_t> IntVector;
typedef TemplatedVector<float> Vector;